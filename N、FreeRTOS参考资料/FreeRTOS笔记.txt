一、FreeRTOS系统移植
	1、完成FreeRTOS移植到stm32的LED灯的项目
		1.1、参考正点原子的视频
		1.2、新建FreeRTOS文件夹，添加相应的文件
		1.3、添加头文件的链接，如FreeRTOS.h与RVDS文件
		1.4、移植过程中遇到的问题：
			1.4.1、port.c文件中总是提示跟汇编有关的错误
				解决办法：直接去已经移植好的文件把他们的port.c文件复制过来
			1.4.2、FreeRTOSconfig.h总是有问题，要么是链接问题，要么是宏定义错误问题
				解决办法：不同的硬件平台使用config文件不相同，我的是F103系列的，而教程给的是F473系列的
					所以，才导致这些错误。从官方的demo中找到F103系列的config文件即可。
	1、使用自己移植的freeRTOS系统没能够实现功能
		但是，移植的方法已经掌握，具体如下：
			1、移植FreeRTOS的内核文件，一共六个文件，如task、timer、list、queue、heap、port等
			2、添加包含的头文件路径
			3、添加FreeRTOSconfig文件
		目前已经实现
		
二、FreeRTOS基础知识
	1、FreeRTOS的前缀规则
		v：void类型
		u：unsigned类型
		x：用户自定义的数据类型，如结构体，队列等。
			那么，ux即为，用户自定义的无符号类型数据
		s：short
		c：char
		e：enum
		p：指针类型
			那么，pus即为，无符号char类型的指针
		prv：static函数

三、任务管理
	1、任务的创建
		1.1、API函数的使用
			portBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode,		任务函数的指针
			const signed portCHAR * const pcName,					任务函数名，方便调试使用
			unsigned portSHORT usStackDepth,						栈的深度
			void *pvParameters,										传入任务函数的参数，假如没有的话配置为NULL
			unsigned portBASE_TYPE uxPriority,						任务优先级，最低为0，最高为maxPriority-1
			xTaskHandle *pxCreatedTask );							任务句柄，用于删除任务，改变任务优先级的东西。注意，传入的是二级指针
		1.2、具体例子应用
			1.1.1、单任务创建，控制一个颜色的灯
			1.1.2、实现多任务控制不同的灯的颜色
		1.n、本小结遇到的问题点
			1、为什么任务没有被执行，灯没有亮？
				目前没有找到原因，不知道是不是创建函数配置参数出错导致
				原因是FreeRTOSconfig文件配置的问题，移植官方F103的配置文件即可
			2、为什么使用官方的freeRTOS系统刷完程序之后需要断电再上电或者复位芯片才能正常工作？
	2、任务删除 
		2.1、vTaskDelete(被删除任务的句柄)
		
		2.n、本小结遇到的问题点
			1、任务删除部分，有些疑惑
			1、为什么有时候删不掉任务呢？
				macLED1_ON();		
				vTaskDelete(CreateRed_Handler);
				例如上面这种情况，按照我的理解，LED1状态只会亮一下，然后本任务就会被删除，但按照现象看，好像任务没有被删除
					或者说又重新被创建了似的。我猜测跟任务的运行状态有关系，所以，我现在去那里找找资料。
				出错的原因找到了：
					1、xTaskCreate()中最后一个参数，句柄应该是传入它的地址。
					2、vTaskDelete()之前需要加判断，必须是句柄不为空才执行删除操作，并且在删除之后需要把句柄置空。

	3、任务优先级设置
		3.1、vTaskPrioritySet(任务句柄、优先级数值)
		3.2、uxTaskPriorityGet(NULL)，值得注意的是，获取的是当前任务的优先级
		
	4、任务的四个状态
		运行态(running)：正在运行的任务，由于是单核CPU，所以同一时刻，只有一个任务被执行
				状态机图： 
					运行->就绪 
					运行->挂起 
					运行->阻塞
					就绪->运行
		就绪态(ready)：等待被执行的任务，进入运行态的唯一方式是先处在就绪态。
				状态机图：
					就绪->运行
					就绪->挂起
					挂起->就绪 
					运行->就绪
					阻塞->就绪
		阻塞态(blocked)：简述形成的原因：有些任务不常用，例如任务B是判断IO口是否有数据输入。任务A为常规任务，如每秒打印一次当前的时间。B任务优先级比A任务高
				所以，假如AB同时在就绪状态，那么A任务则没有机会执行。所以我们需要把AB任务放在不同的状态，以便于处理。则引入阻塞态，把B任务
				放入其中，当没有输入时，B任务不被执行，处于等待状态，有输入时，则被送入就绪态
				状态机图：
					阻塞->挂起
					阻塞->就绪
					就绪->阻塞
					运行->阻塞
		挂起态(suspender)：当系统任务过多的时候，阻塞态会有大量的任务被阻塞于其中，不利于管理，况且很多是不常用的任务，也消耗了很多内存
				于是把不常用的任务挂起，存入硬盘。
				状态机图：
					挂起->就绪 
					就绪->挂起
					运行->挂起
					阻塞->挂起
		
	5、任务调度算法
		1、优先级调度算法
			原理：根据任务的优先级来决定它被执行的先后顺序，也就是优先级高的任务先被执行，优先级低的任务往后排队
			应用场景：处在就绪态的任务采用此调度算法
		2、先进先出调度算法
			原理：对于同等优先级的任务，采用先进先出的方式，与堆的方式相同
			应用场景：当同时有两个任务在就绪状态，则使用此算法
		3、时间片轮询调度算法
			原理：对于一个任务而言，不可能总是被执行，不然其他任务没法工作，所以，同优先级的任务，各自执行一段时长，保证每个任务都可以被执行
			应用场景：同等优先级的任务，轮询执行一段时长

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
